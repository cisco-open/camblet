---
title: "Nasp intro post"
author: "Janos Matyas"
layout: "@layouts/BlogLayout.astro"
publishDate: "2022-11-05 15:36"
tags: [nasp, zero-trust]
---

## Why Zero Trust?

Zero Trust security, also known as Zero Trust architecture, has emerged as a prevalent strategy among security-conscious organizations. While Zero Trust encompasses various approaches and solutions, including Nasp's unique approach, let’s first focus on the core benefits and shared objectives of a Zero Trust strategy.

- Enhanced Security Posture: Zero trust networks adopt a "never trust, always verify" approach, continuously authenticating and authorizing users, devices, and applications before granting access to resources.
- Reduced Attack Surface: Zero trust networks eliminate the traditional network perimeter, which is often a weak point that attackers exploit. By segmenting the network and enforcing granular access controls, zero trust reduces the attack surface, making it more difficult for attackers to gain access to critical systems and data.
- Enhanced Compliance: Zero trust networks can help organizations meet compliance requirements by providing auditable records of user access and activities. This can be particularly important for organizations in regulated industries, such as healthcare and finance.
- Reduced Costs: While implementing a zero trust network may require upfront strategy investment, it can lead to long-term cost savings by reducing the risk of data breaches and other security incidents.

## Zero Trust the Nasp way

While these high-level goals may necessitate diverse approaches and technologies, let's examine their implications for Nasp and explore how we align these goals with our more granular and specific technological approach. We believe to cover the above we should focus on the following three pillars:

- PKI management
- mTLS based identity
- and Policy

The intricate details of our implementation are elaborated upon in the documentation, but let's delve into some key aspects. Mutual Transport Layer Security (mTLS), a cryptographic authentication protocol that extends Transport Layer Security (TLS), is essential for workloads to authenticate each other. Unlike traditional TLS, where only the server presents its certificate, mTLS requires both client and server to present their respective certificates, verified using public-key cryptography. In our context, workloads are analogous to clients and servers. These certificates serve as "identities" for our workloads and are automatically generated by Nasp (assisted by a CA signer and kTLS), issued, and injected into workloads. Nasp, unlike a typical service mesh, operates beyond Kubernetes limitations. It functions on bare metal, VMs, containers, and K8s, and doesn't rely on sidecars (Envoy) for mTLS implementation. Our approach presents several distinctive features:

- Certificate binding to workload host processes (not sidecar containers like Envoy in Istio)
- Confinement of certificates within kernelspace, eliminating certificate leakage into userspace

While the first two pillars (PKI management and mTLS-based identity) are interconnected, the third pillar – Policy – governs which entities can communicate with whom and under what conditions.

## The Rationale behind Nasp

The rise of microservices architectures introduced new challenges in securing distributed applications. Traditional security approaches, such as perimeter-based security, proved inadequate in the dynamic and interconnected microservices landscape. Service meshes emerged as a promising solution, offering centralized traffic management, observability, and security enforcement. However, service meshes presented their own limitations. Their sidecar-based architecture added complexity and overhead, particularly in resource-constrained environments. Additionally, their focus on Kubernetes restricted their applicability to broader deployment scenarios. Nasp was developed to address these shortcomings and provide a more comprehensive and lightweight approach to workload security. Nasp is eliminating the need for sidecars and reducing operational overhead. Nasp's broader compatibility extends beyond Kubernetes to encompass bare metal, VMs, and containers, making it a versatile solution for diverse infrastructure environments.

While Nasp shares some key features with service meshes, such as mTLS, it fundamentally differs in its approach and scope. Nasp operates at the host level, integrating seamlessly with the operating system to enforce security policies. In contrast, service meshes typically rely on sidecars, introducing an additional layer of complexity and resource consumption. Nasp's initial iteration took the form of a library-based approach, extending service mesh capabilities beyond Kubernetes and eliminating the need for sidecars. Leveraging WebAssembly, the current Nasp version also incorporates WebAssembly components, such as running OPA policies within the Linux kernel. It embraced Envoy filters and secured workloads, including the library, with mTLS. However, its reliance on Istio restricted its flexibility and potential.

Considering the drawbacks of service meshes, such as complexity, resource overhead, and limited applicability, we decided to revolutionize workload security by moving away from service mesh reliance and automating identity and secure communication at the core of the system – within the Linux kernel.
